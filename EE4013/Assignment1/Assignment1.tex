\documentclass[journal,12pt,twocolumn]{IEEEtran}

\usepackage{setspace}
\usepackage{gensymb}
\singlespacing
\usepackage[cmex10]{amsmath}

\usepackage{amsthm}

\usepackage{mathrsfs}
\usepackage{txfonts}
\usepackage{stfloats}
\usepackage{bm}
\usepackage{cite}
\usepackage{cases}
\usepackage{subfig}

\usepackage{longtable}
\usepackage{multirow}

\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{steinmetz}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage{tfrupee}
\usepackage[breaklinks=true]{hyperref}
\usepackage{graphicx}
\usepackage{tkz-euclide}
\usetikzlibrary{shapes,arrows}

\usetikzlibrary{calc,math}
\usepackage{listings}
    \usepackage{color}                                            %%
    \usepackage{array}                                            %%
    \usepackage{longtable}                                        %%
    \usepackage{calc}                                             %%
    \usepackage{multirow}                                         %%
    \usepackage{hhline}                                           %%
    \usepackage{ifthen}                                           %%
    \usepackage{lscape}     
\usepackage{multicol}
\usepackage{chngcntr}

\DeclareMathOperator*{\Res}{Res}

\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}


\hyphenation{op-tical net-works semi-conduc-tor}
\def\inputGnumericTable{}                                 %%

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}
\begin{document}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{definition}[problem]{Definition}

\newcommand{\BEQA}{\begin{eqnarray}}
\newcommand{\EEQA}{\end{eqnarray}}
\newcommand{\define}{\stackrel{\triangle}{=}}
\bibliographystyle{IEEEtran}
\raggedbottom
\setlength{\parindent}{0pt}
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
\providecommand{\abs}[1]{\left\vert#1\right\vert}
\providecommand{\res}[1]{\Res\displaylimits_{#1}} 
\providecommand{\norm}[1]{\left\lVert#1\right\rVert}
%\providecommand{\norm}[1]{\lVert#1\rVert}
\providecommand{\mtx}[1]{\mathbf{#1}}
\providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
%\providecommand{\hilbert}{\overset{\mathcal{H}}{ \rightleftharpoons}}
\providecommand{\system}{\overset{\mathcal{H}}{ \longleftrightarrow}}
	%\newcommand{\solution}[2]{\textbf{Solution:}{#1}}
\newcommand{\solution}{\noindent \textbf{Solution: }}
\newcommand{\cosec}{\,\text{cosec}\,}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\numberwithin{equation}{subsection}

\makeatletter
\@addtoreset{figure}{problem}
\makeatother
\let\StandardTheFigure\thefigure
\let\vec\mathbf

\renewcommand{\thefigure}{\theproblem}

\def\putbox#1#2#3{\makebox[0in][l]{\makebox[#1][l]{}\raisebox{\baselineskip}[0in][0in]{\raisebox{#2}[0in][0in]{#3}}}}
     \def\rightbox#1{\makebox[0in][r]{#1}}
     \def\centbox#1{\makebox[0in]{#1}}
     \def\topbox#1{\raisebox{-\baselineskip}[0in][0in]{#1}}
     \def\midbox#1{\raisebox{-0.5\baselineskip}[0in][0in]{#1}}
\vspace{3cm}
\title{EE4013 Assignment-1}
\author{Krishna Srikar Durbha - EE18BTECH11014}
\maketitle
\newpage
\bigskip
\renewcommand{\thefigure}{\theenumi}
\renewcommand{\thetable}{\theenumi}
Download all codes from 
\begin{lstlisting}
https://github.com/dks2000dks/IIT-Hyderabad-Semester-Courses/tree/master/EE4013/Assignment1/codes
\end{lstlisting}
%
and latex-tikz codes from 
%
\begin{lstlisting}
https://github.com/dks2000dks/IIT-Hyderabad-Semester-Courses/tree/master/EE4013/Assignment1
\end{lstlisting}
\section{Problem}
Consider the following ANSI C function:
\begin{lstlisting}[language=C]
int SomeFunction(int x, int y){
	if ((x == 1) || (y == 1)) return 1;
	if (x == y) return x;
	if (x > y) return SomeFunction(x-y, y);
	if (x < y) return SomeFunction(x, y-x);
}
\end{lstlisting}
The value of returned by SomeFunction(15,255) is \rule{1cm}{0.15mm}
\section{Solution}
\subsection{Answer}
\quad Let \textbf{SomeFunction} be represented as $f$. The recursion goes as follows:
\[
\begin{split}
&f(15,255) = f(15,240) = f(15,225) = f(15,210)\\
&= f(15,195) = f(15,180) = f(15,165) = f(15,150)\\
&= f(15,135) = f(15,120) = f(15,105) = f(15,90)\\
&= f(15,75) = f(15,60) = f(15,45) = f(15,30)\\
&= f(15,15) = 1
\end{split}\]

\quad One other approach is that knowing or recognising that $f$ is an implementation of Euclidean Algorithm by Subtraction for calculating GCD of positive integers $x$ and $y$.
\begin{align}
	gcd(15,255) = 15 \text{ (As $15 \times 17 = 255$)} 
\end{align}

\subsection{Euclidean Algorithm by Subtraction}
Euclidean Algorithm is a recursive method of finding Greatest Common Divisor of 2 numbers. For some positive integers $a$ and $b$, Euclidean Algorithm by Subtraction repeatedly subtracts the smaller number from the larger one. $gcd(a,b) = gcd(a-b,b)$ considering that $a > b$. We repeat the procedure till convergence i.e both numbers are equal. At this point, the value of either term is the greatest common divisor of our inputs.\\
\textbf{Proof:}\\
Proof involves proving that, subtracting between $a$ and $b$ doesn't change GCD. Let $a$, $b$ be 2 positive integers such that $gcd(a,b) = m$ and $a > b$. So, it can be written as,
\begin{align}
    a = a_{1} \times m \\
    b = b_{1} \times m \\
    gcd(a,b) = m \implies gcd(a_{1}, b_{1}) = 1
\end{align}
We need to prove that $gcd(a-b,b) = m$. We will prove it by contradiction. Let $gcd(a-b,b) = M$ where $M > m \implies 
 k \neq 1$
\begin{align}
    a-b = (a_{1} - b_{1}) \times m\\
    b =  b_{1} \times m\\
    gcd(a-b,b) = M\\
    M = k \times m \text{ (For some integer $k$)}\\
    a-b \equiv 0\ (\textrm{mod}\ M) \text{ and } b \equiv 0\ (\textrm{mod}\ M)\\
    a-b \equiv 0\ (\textrm{mod}\ km) \text{ and } b \equiv 0\ (\textrm{mod}\ km)\\
    a_{1} - b_{1} \equiv 0\ (\textrm{mod}\ k) \text{ and } b_{1} \equiv 0\ (\textrm{mod}\ k)\\
    a_{1} \equiv 0\ (\textrm{mod}\ k) \text{ and } b_{1} \equiv 0\ (\textrm{mod}\ k)
\end{align}
We know that $gcd(a_{1}, b_{1}) = 1$, so $a$ and $b$ cannot have a common divisor $k$. Hence by contradiction, there doesn't exist a $M \neq m$ such that $gcd(a-b, b) = M$. Hence it can be proved that, $gcd(a, b) = gcd(a-b, b) = m$ for $a > b$.\\

\subsubsection{Complexity Analysis}
Let $a > b$ and $T(n)$ denote time complexity of $gcd(a,b)$ where $n = a+b$. Then,
\begin{align}
T(n) = 1 + T(n-b)\\
T(n-b) = 1 + T(n-2b) \text{ if $a > 2b$}\\
T(n-b) = 1 + T(n-a-b) \text{ if $b < a < 2b$}
\end{align}

On assuming $n > (x_{1}a + x_{2}b)$ for some $x_{1}, x_{2}$, $T(n)$ can be written as:
\begin{align}
T(n) = k + T(n - x_{1}a - x_{2}b) \text{ (For $k = x_{1} + x_{2}$)}
\end{align}
No.of steps vary linearly with $n=a+b$. So, in the worst-case scenerio the algorithm performs $a+b$ subtractions. Hence Worst Case Time-Complexity for calculating GCD of $a$ and  $b$ using Euclidean Algorithm by Subtraction is $\mathcal{O}(a + b)$.\\

\begin{figure}[h!]
	\begin{center}
		\resizebox{\columnwidth/1}{!}{\input{./figs/figa.tex}}
	\end{center}
	\caption{Flowchart of Euclidean Algorithm by Subtraction}
	\label{fig:Input}
\end{figure}

Codes of Euclidean Algorithm by Subtraction:
\begin{lstlisting}
codes/Euclid_Subtraction.py
codes/Euclid_Subtraction.c
\end{lstlisting}

\subsection{Euclidean Algorithm by Division}
Euclidean Algorithm by Division involves divison rather than subtraction. For some positive integers $a$ and $b$, $gcd(a, b) = gcd(b, a \textrm{ mod}\ b)$. We repeat the procedure until convergence.\\

Let $a$ and $b$ be 2 positive integers such that $a > b$. By applying Euclid's Algorithm from $0^{th}$-step,\\
\begin{align}
	a = q_{0}b + r_{0}\label{eq:ED1}\\
	b = q_{1}r_{0} + r_{1}\\
	r_{0} = q_{2}r_{1} + r_{2}\\
	r_{1} = q_{3}r_{2} + r_{3}...
\end{align}
Here $a > b$, $ b > r_{0}$, $r_{0} > r_{1}$, $r_{1} > r_{2}$.. and so on. So, remainders are decreasing after each step.

Let at $n^{th}$-step $r_{n-2} = q_{n}r_{n-1}$ i.e $r_{n} = 0$.
 \begin{align}
    r_{n-2} = q_{n}r_{n-1}\label{eq:ED2}\\
    r_{n-3} = q_{n-1}r_{n-2} + r_{n-1}\\
    r_{n-1} \text{ divides } r_{n-2}, r_{n-3}, r_{n-4},..., r_{1}, r_{0}, b, a\\
    a \equiv 0\ (\textrm{mod}\ r_{n-1}) \text{ and } b \equiv 0\ (\textrm{mod}\ r_{n-1})
\end{align}
So, $r_{n-1}$ is a common divisor of both $a$ and $b$. Let $gcd(a,b) = M \implies M > r_{n-1}$,\\
\begin{align}
    a = a_{1} \times M \text{ and } b = b_{1} \times M\\
    r_{0} = a - q_{0}b = M(a_{1} - q_{0}b_{1})\\
    r_{1} = b - q_{1}r_{0} = M(b_{1} - q_{1}a_{1} + q_{1}q_{0}b_{1})
\end{align}
So, M divides $a, b, r_{0}, r_{1}, ... $ and so on all the following remainders. So, $M$ should divide $r_{n-1}$, which implies $r_{n-1} \geq M$ which is a contraction as $M > r_{n-1}$. Hence by contradiction, there doesn't exist a $M > r_{n-1}$ which is a divisor of $a$ and $b$. So, $gcd(a,b) = r_{n-1}$.\\

\quad On using Euclidean Algorithm by Division the recursion goes as follows:
\[
\begin{split}
&gcd(15,255) = gcd(255,15) = gcd(15,0) = 15
\end{split}\]

\subsubsection{Complexity Analysis}
Let $f_{n}$ denote elements in Pingala Sequence starting from $n=0$ where $f_{0} = 0, f_{1} = 1, f_{2} = 1,...$ and so on. Elements of the sequence can be written as follows:
\begin{align*}
f_{n+2} = 1 \times f_{n+1} + f_{n}\\
f_{n+1} = 1 \times f_{n} + f_{n-1}\\
...........................\\
f_{4} = 1 \times f_{3} + f_{2}\\
f_{3} = 2 \times f_{2}
\end{align*}
The above equations are similar to equations in Euclidean Algorithm by Division i.e from \eqref{eq:ED1} to \eqref{eq:ED2}. Hence it can be proved that $gcd(f_{n+2}, f_{n+1}) = f_{2} = 1$ and takes $n$ steps to converge.\\

If $gcd(a,b)$ takes $n$ steps to converge by using Euclidean Algorithm by Division, then $a \geq f_{n+2}$ and $b \geq f_{n+1}$.\\

\textbf{Proof by Mathematical Induction:}\\
Let $a = 2$ and $b = 1$. Then, $gcd(2,1) = 1$ takes $1$ step to converge. $a \geq f_{3} = 2$ and $b \geq f_{2} = 1$. Assuming statements hold true at ${n-1}^{th}$ step, $gcd(b,a\%b)$ takes $n-1$ steps to converge.
\begin{align}
b \geq f_{n+1}\\
a\%b \geq f_{n}\\
a = q_{0}b + a\%b\\
a \geq b + a\%b\\
a \geq f_{n+1} + f_{n}\\
a \geq f_{n+2}
\end{align}
Hence proved.\\

Let $gcd(a,b)$ takes $n$ steps to converge. Then,
\begin{align}
a \geq f_{n+2}\\
b \geq f_{n+1}\\
f_{n}=\frac{1}{\sqrt{5}}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{n}-\left(\frac{1-\sqrt{5}}{2}\right)^{n}\right)\\
\phi = \frac{1+\sqrt{5}}{2}\\
f_{n} \approx \phi^{n}\\
b \approx \phi^{n+1}\\
n \approx \log_{\phi}{\left(min(a,b)\right)}
\end{align}
So, in the worst-case scenerio the algorithm performs $n \approx \log_{\phi}{\left(min(a,b)\right)} $ divisons. Hence, Worst Case Time-Complexity for calculating GCD of $a$ and  $b$ using Euclidean Algorithm by Division is $\mathcal{O}(\log min(a,b))$.\\

\begin{figure}[h!]
	\begin{center}
		\resizebox{\columnwidth/1}{!}{\input{./figs/figb.tex}}
	\end{center}
	\caption{Flowchart of Euclidean Algorithm by Division}
	\label{fig:Input}
\end{figure}

Codes of Euclidean Algorithm by Division:
\begin{lstlisting}
codes/Euclid_Division.py
codes/Euclid_Division.c
\end{lstlisting}

\textbf{Another Example:}\\
The following example illustrates the difference in no.of steps between Euclidean Algorithm by Subtraction and Euclidean Algorithm by Divison. To find GCD of two numbers $24$ and $92$.\\

By Euclid's Subtraction,
\[
\begin{split}
&f(24,92) = f(24,68) = f(24,44) = f(24,20)\\
&= f(4,20) = f(4,16) = f(4,12) = f(4,8)\\
&= f(4,4) = 4
\end{split}\]

By Euclid's Division,
\[
\begin{split}
&f(24,92) = f(92,24) = f(24,20) = f(20,4)\\
&= f(4,0) = 4
\end{split}\]

The difference in no.of steps indicates the performance improvement of Euclidean Algorithm by Division over Subtraction.

\end{document}
